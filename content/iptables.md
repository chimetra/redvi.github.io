Title: Firewall в Linux. Настройка iptables
Date: 2011-09-02 08:25
Tags: Linux
Slug: iptables
Author: redVi
Summary: Iptables отвечает преимущественно за фильтрацию пакетов. Настройка Iptables вручную является довольно непростой задачей.

Iptables отвечает преимущественно за фильтрацию пакетов. Настройка Iptables вручную является довольно непростой задачей. Не надейтесь, что разберётесь в этом «снаскока». К счастью, есть много инструментов, которые могут оказать вам помощь в случае, если с iptables вы ещё не разобрались, а обезопасить систему нужно срочно: fwbuilder, firestarter, guarddog, arno firewall &mdash; по сути это GUI к iptables. Однозначного ответа что лучше нет. Выбирать вам. Однако, сегодняшняя статья посвящена именно iptables и делится на две части: теория и практика. Самые нетерпеливые могут сразу выполнить практическую часть, хотя подобный подход не рекомендуется.


**Внимание!** Все действия с iptables производятся от имени привелигированного пользователя!

## Теория

Формат записи iptables
: iptables [-t таблица] [команда] [действие]

Пример:
: iptables -t filter -A INPUT ACCEPT


**Действия**

* ACCEPT --- Принять пакет
* DROP --- Отбросить пакет
* DNAT --- Преобразовать адрес назначения
* SNAT --- Изменить исходящий IP-адрес в заголовке пакета
* LOG --- Журналирование пакетов и событий
* MARK --- Установить метку на пакет
* MASQUERADE  ---  Изменить исходящий IP-адрес в заголовке пакета (отличие от SNAT - работа с динамическими IP)
* QUEUE --- Поставить пакет в очередь на обработку
* REDIRECT --- Перенаправить пакет/поток на другой порт
* REJECT --- Отбросить пакет+уведомить удалённую систему о том. что её пакет отвергнут
* RETURN --- Прекратить движение пакета по текущей цепочке и возвратить в вызывающую цепочку

**Команды**

* -A --- Добавить правило в цепочку
* -D --- Удалить правило из цепочки
* -R --- Заменить одно правило другим
* -I --- Вставить новое правило
* -L --- Вывести список существующих правил
* -F --- Сброс правил
* -Z --- Обнуление счётчиков в заданной цепочке
* -N --- Создание новой цепочки с заданным именем
* -X --- Удаление цепочки
* -P --- Задать политику по умолчанию для выбранной цепочки
* -E --- Переименовать пользовательскую цепочку


**Критерии (общие)**


* -p --- Указать тип протокола
* -s --- IP-адрес источника пакета
* -d --- IP-адрес получателя пакета
* -j --- Указать действие для правила
* -i --- Интерфейс, с которого был принят пакет
* -o --- Указать имя выходного интерфейса
* -f --- Распространить правило на все фрагменты пакета

**TCP критерии:**

* --sport --- Порт,с которого отправлен пакет
* --dport --- Порт,на который адресован пакет
* --tcp-flags --- Определить маску и флаги пакета

**UDP критерии:**

* --sport --- Порт,с которого отправлен пакет
* --dport --- Порт,на который адресован пакет


Подробнее в man iptables

##Практика

**Просмотр текущей конфигурации**

```console
# iptables -L

Chain INPUT (policy ACCEPT)
target prot opt source destination

Chain FORWARD (policy ACCEPT)
target prot opt source destination

Chain OUTPUT (policy ACCEPT)
target prot opt source destination
```

Если вы узрели подобное, значит ваш файрволл ещё не настроен и разрешает всё. Исправим положение.

**Настройка политики по умолчанию**

* iptables -P INPUT DROP --- блокирование входящих пакетов
* iptables -P OUTPUT ACCEPT --- разрешить исходящие пакеты
* iptables -P FORWARD DROP --- обработка пакетов, которые попали на сервер с другой машины и ожидают дальнейшего переброса. В примере блокируется. В таком случае вам придётся дописать правила для доверенных машин.

Поскольку входящие пакеты INPUT блокированы, пропишем правило:

```console
# iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
```

Это разрешит принимать пакеты от ранее установленного соединения и принимать новые пакеты,порождённые этим соединением.

Либо с указанием типа протокола:

```console
# iptables -A INPUT -p TCP -m state --state ESTABLISHED,RELATED -j ACCEPT
# iptables -A INPUT -p UDP -m state --state ESTABLISHED,RELATED -j ACCEPT
```

Теперь локальный интерфейс:

```console
# iptables -A INPUT -i lo -j ACCEPT
```

* NEW --- данные, начинающие новое соединение.
* ESTABLISHED --- пакет, приходящий от уже установленного соединения.
* RELATED --- новый пакет данных, но порожденный старым установленным соединением
* INVALID --- итак понятно

Сохранить настройки (можете прописывать настройки iptables непосредственно в созданный файл):

```console
# iptables-save > /etc/iptables.up.rules
```

Включить эти правила:

```console
# iptables-restore < /etc/iptables.up.rules
```

И увидеть разницу:

```console
# iptables-L
```

Запуск iptables при старте системы:

В каталоге `/etc/init.d` создаем файл с именем iptables

```console
# touch /etc/init.d/iptables
```

Прописываем в нём следующее:

```sh
#!/bin/sh
/sbin/iptables-restore < /etc/iptables.up.rules
```

Делаем файл iptables исполняемым:

```console
# chmod +x /etc/init.d/iptables
```

Добавляем его в автозапуск

```console
# update-rc.d -n iptables defaults
```

Запуск iptables при подключении к сети:

```console
# echo "#! /sbin/iptables-restore" > /etc/network/if-up.d/iptables.up.rules
# iptables-save >> /etc/network/if-up.d/iptables.up.rules
# chmod +x /etc/network/if-up.d/iptables.up.rules
```

*Примечание:* в любой момент вы можете проверить загружены ли ваши правила, просто введя от рута
`iptables-save`

Для archlinux сохранение правил iptables осуществляется командой:

```console
# rc.d save iptables
```
