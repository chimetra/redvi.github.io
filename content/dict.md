Title: Пишем консольный словарь на python
Date: 2012-12-18 08:15
Tags: Python
Slug: dict
Author: redVi
Summary: Пост создан для рассмотрения небольшого примера возможностей языка python.

Пост создан для рассмотрения небольшого примера возможностей языка python. Мы не станем углубляться в сложные темы языка, например, такие как объектно-ориентированное программирование и связанные с ним классы. Да, они являются мощным инструментом для создания сложных приложений, но нам этого пока не требуется.

<b>Цель:</b> создать англо-русский, русско-английский словарь с возможностью вносить в него новые, пользовательские значения.

Первое, что приходи на ум &mdash; словари языка python.

Словарь в питоне - неупорядоченная последовательность пар ключ - значение. Что, собственно, и требовалось, верно?

<b>Пример 1.</b>

Итак, первый файл должен содержать сам словарь с некоторыми значениями.

Создадим его. Назовём `words.py`

    :::python
    # words.py
    #
    words={'word': 'мир',\
        'earth':'земля',\
        'you': 'ты',\
        'I':'я',\
        'We':'мы',\
        'probably':'вероятно',\
        'piece':'кусок',\
        'tired':'усталый',\
        'should':'должен',\
        'be able':'быть в состоянии',\
        'not enough':'не хватает',\
        'enough':'достаточно',\
        'should':'должен',\
        'represent':'представлять',\
        'sequence':'последовательность'}

И так далее.
Теперь нужно как-то спросить у пользователя, перевод какого именно слова он хотел бы найти и вывести значение на экран. Кроме того, не стоит забывать, что наш словарь работает в двух направлениях: он должен не только переводить с английского на русский, но и наоборот!

Создадим стартовый файл с функциями, запускающими в зависимости от предпочтений пользователя тот или иной вариант перевода.

    :::python
    # mydictionary.py
    #
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    from words import words

    def eng():
        eng_words=dict([[v, k] for k,v in words.items()])
        find_word=input('Enter word ' '')
        print(eng_words.get(find_word) or print('No such key'))

    def rus():
        key=input('Введите слово ' '')
        print (words.get(key) or 'Искомое слово не найдено')

    if __name__ == '__main__':
        x=input('Найти перевод английского слова? ' '')
        if x == 'y':
            rus()
        elif x == 'n':
            eng()
        else:
            print('Увидимся позже')


Отлично! Разберём построчно:

`from words import words` &mdash; импортируем из файла words.py сам словарь &mdash; `words`

Пишем две функции: `eng` и `rus` без параметров.

`eng_words=dict([[v, k] for k,v in words.items()])` &mdash; это словарь "наоборот" для перевода русских слов на английские, теперь ключи стали значениями, а значения &mdash; ключами!

`find_word=input('Enter word ' '')` - просим пользователя ввести искомое слово

`print(eng_words.get(find_word) or print('No such key'))` &mdash; выводим на экран ответ с помощью функции `print`, получаем значение (`get`). В противном случае, отвечаем, что не смогли отыскать нужное слово.

Функция `rus()` работает так же, но без инвертирования словаря.

Вы уже догадались: наш словарь "наоборот" нужен для того, чтобы не приходилось писать два словаря &mdash; мы просто меняем ключи и значения местами.

Попробуйте запустить `mydictionary.py` и насладитесь результатом.

Что сейчас делает наша программа?

Спрашивает искомое слово, выводит ответ. Но осталось ощущение, что всё слишком просто и чего-то не хватает. Давайте немного усложним задачу: создадим базу данных для словаря и дадим пользователю возможность добавлять свои значения.

<b>Пример 2.</b>

Создание базы данных. Файл `words_db.py`

    :::python
    # words_db.py
    #
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import shelve
    db = shelve.open('db_file')
    db['earth']='земля'
    db['word']='слово'
    db['catch']='ловить'
    db['find']='искать'
    db.close()


База данных создаётся при помощи модуля `shelve`, импортируем его. Далее укажем входной файл: `db_file`, он открывается, в него записываются данные &mdash; теперь именно это наш словарь. Файл `words.py`, используемый в первом примере, нам больше не нужен.

После записи значений, базу данных нужно закрыть &mdash; `db.close()`. Создайте нашу базу данных &mdash; `db_file`:

`$ python words_db.py`

Восстановление базы данных из файла `db_file`

    :::python
    # dump_words_db.py
    #
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import shelve
    db=shelve.open('db_file')
    print('Yes')


Мы больше не используем просто словарь, значит и наш главный файл, запускающий функции, должен измениться. Напишем его:

    :::python
    # start_programm.py
    #
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import shelve
    db=shelve.open('db_file')

    def eng():
        eng_words=dict([[v, k] for k,v in db.items()])
        find_word=input('Enter word ' '')
        print(eng_words.get(find_word) or print('No such key'))

    def rus():
        key=input('Введите слово ' '')
        print (db.get(key) or 'Искомое слово не найдено')

    def newRecord():
        newkey=input('Ввести новое слово ' '')
        newvalue=input('Ввести перевод ' '')
        db[newkey] = newvalue
        db.update()
        db.close()

    if __name__ == '__main__':
        start=input('Найти английский перевод русского слова? введите "y" или "n" ' '')
        if start == 'y':
            eng()
        elif start == 'n':
            rus()
        elif start == 'u':
            newRecord()
        else:
            print('До встречи')


Рассмотрим подробнее

    :::python
    import shelve
    db=shelve.open('db_file')


Мы импортировали модуль `shelve` и открыли нашу базу данных, содержащую словарь

Далее создали функцию, которая будет искать в файле `db_file` значение ключа. В случае с функцией `eng()` &mdash; значения в словаре инвертируются.


    :::python
    def eng():
        eng_words=dict([[v, k] for k,v in db.items()])
        find_word=input('Enter word ' '')
        print(eng_words.get(find_word) or print('No such key'))


Кроме того, нужно дать пользователю внести свои значения - дополнить словарь, если он не нашёл в нём перевода нужного слова.

За это отвечает функция `newRecord()`, которая предлагает ввести новые ключ и значение, а затем записывает их в базу данных и обновляет её.

    :::python
    def newRecord():
        newkey=input('Ввести новое слово ' '')
        newvalue=input('Ввести перевод ' '')
        db[newkey] = newvalue
        db.update()
        db.close()




Что означает последняя запись? Она работает, когда запускается программа и предлагает различные варианты. Если пользователь ввёл в ответ `'y'` &mdash; ищет перевод русского слова на английский, если `'n'` &mdash; ищет перевод английского слова на русский, если `'u'` (update) &mdash; позволяет внести свои значения.

    :::python
    if __name__ == '__main__':
        start=input('Найти английский перевод русского слова? введите "y" или "n" ' '')
        if start == 'y':
            eng()
        elif start == 'n':
            rus()
        elif start == 'u':
            newRecord()
        else:
            print('До встречи')


Наш словарь отрабатывает один раз и программа закрывается. Можно спрашивать о действиях снова и снова, для этого достаточно заключить инструкции в цикл `while`. Можно добавить графическое представление программы или "веб-морду". Но это уже совсем другая история и для примера простой программы она не подойдёт.
